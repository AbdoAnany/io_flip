import 'dart:async';

import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:top_dash/match_making/match_making.dart';
import 'package:uuid/uuid.dart';

part 'match_making_event.dart';
part 'match_making_state.dart';

class MatchMakingBloc extends Bloc<MatchMakingEvent, MatchMakingState> {
  MatchMakingBloc({
    required MatchMaker matchMaker,
  })  : _matchMaker = matchMaker,
        super(const MatchMakingState.initial()) {
    on<MatchRequested>(_onMatchRequested);
  }

  final MatchMaker _matchMaker;

  Future<void> _onMatchRequested(
    MatchRequested event,
    Emitter<MatchMakingState> emit,
  ) async {
    try {
      emit(state.copyWith(status: MatchMakingStatus.processing));
      // TODO(erickzanardo): using this to test the match making for now,
      // this id should be the id of the ticket generated by the drafting
      // phase.
      final id = const Uuid().v4();
      final match = await _matchMaker.findMatch(id);

      if (match.guest != null) {
        emit(
          state.copyWith(
            match: match,
            status: MatchMakingStatus.completed,
          ),
        );
      } else {
        final stream = _matchMaker.watchMatch(match.id);
        emit(state.copyWith(match: match));

        final newMatch = await stream.firstWhere(
          (match) => match.guest != null,
        );

        emit(
          state.copyWith(
            match: newMatch,
            status: MatchMakingStatus.completed,
          ),
        );
      }
    } catch (e, s) {
      addError(e, s);
      emit(state.copyWith(status: MatchMakingStatus.failed));
    }
  }
}
